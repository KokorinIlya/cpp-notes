\section{Задача Perfect forwarding}

\subsection{Формулировка проблемы, попытки тривиального решения}

Пусть у нас есть функция g, имеющая параметр типа T. Мы хотим написать функцию f, которая имеет параметр этого же типа T и вызывает функцию g от этого параметра. Задача написания такого f называется задачей forwarding'а. Говорят функция f форвардит свой аргумент в g.

Примером пары таких f и g из стандартной библиотеки являются make\_unique<T>(params) и конструктор T. make\_unique сначала вызывает конструктор T с заданными аргументами, а потом оборачивает получившийся объект в unique\_ptr.

Вот пример простейшей реализации функции f:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T x)
{
    g(x);
}
\end{minted}

Эта реализация имеет недостатки. Предположим, что функция g принимает параметр по неконстантной ссылке и меняет его. В этом случае:

\begin{itemize}
\item При вызове функции f параметр x инициализируется копией передаваемого в f аргумента
\item В g будет передана ссылка на x
\item g изменит x, исходный аргумент функции f останется неизменным.
\end{itemize}

Это не желаемое поведение. Желаемым поведением в данном случае является, что раз g изменяет свой аргумент, то f тоже должна.

Можно было бы попытаться исправить эту проблему, принимая аргумент по неконстантной ссылке:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T& x)
{
    g(x);
}
\end{minted}

Однако в этом случае функцию f становится невозможно вызывать для const-объектов и для rvalue-объектов, то есть вызовы f(5) и f(some\_function()) становятся невозможны.

Другим решением было бы принимать принимать аргумент по константной ссылке
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T const& x)
{
    g(x);
}
\end{minted}

Однако в данном случае возникает проблема похожая на случай и приемом по значению: если g принимает аргумент по неконстантной ссылке, f перестает компилироваться (так как константная ссылка не может быть привязана к неконстантной).

Ни одно из приведённых выше решений не подходит для произвольного g. Для того, чтобы написать функцию f, работающую для произвольного g, необходимо иметь две перегрузки f: для одну для константных ссылок и одну для неконстантных.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T const& x)
{
    g(x);
}

template <typename T>
void f(T& x)
{
    g(x);
}
\end{minted}

Это решение может быть применимо в простых случаях, однако оно имеет два серьезных недостатка. По-первых тело f требуется написать дважды. Во-вторых оно не применимо к большому числу аргументов. Если g и f принимают по два параметра, придётся написать четыре перегрузки:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T& a, T& b)

template <typename T>
void f(T const& a, T& b)

template <typename T>
void f(T& a, T const& b)

template <typename T>
void f(T const& a, T const& b)
\end{minted}

для трёх параметров --- 8, а для n --- $2^n$.

Прежде чем рассматривать грамотное C++11 решение этой проблемы, рассмотрим несколько, связанных с ссылками, языковых механизмов C++11.

\subsection{reference collapsing rule}

В C++ не существует ссылок на ссылки. При попытке создать такой тип, ссылки схлопываются (происходит reference collapsing) и получается просто одна ссылка. Например:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T> f(T& x);

int x = 5;
f<int&>(x);
\end{minted}

В качестве T подставляется int\&. При подстановке T -> int\& в T\&,  должно была бы получится ссылка на ссылку int\& \&, но ссылки схлопываются и получается просто int\&. Следовательно сигнатура функции f после подстановки выглядит следующим образом: f<int\&>(int\& x).

Неформально правило reference collapsing в C++03 можно записать в следующем виде \& + \& = \&

С появлением в C++11 rvalue-ссылок потребовалось доопределить правила reference collapsing для них. Эти правила могут быть неформально записаны как “lvalue-ссылка всегда побеждает”. Таким образом, таблица reference collapsing в C++11 выглядит так:

\& + \& = \&

\& + \&\& = \&

\&\& + \& = \&

\&\& + \&\& = \&\&

Приведём несколько примеров этого правила:

\begin{center}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T & x);

int y;
f<int&&>(y);
\end{minted}
&
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T && x);

f<int&&>(some_function());
//some_function возвращает int
\end{minted}
\end{tabular}

Тогда при инстанцировании шаблона T -> int\&\&, сигнатура функции имеет вид

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int&&>(int&& & x);
\end{minted}
&
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int&&>(int&& && x);
\end{minted}
\end{tabular}

После reference collapsing она превращается в:

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int&&>(int&& x);
\end{minted}
&
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int&&>(int&& x);
\end{minted}
\end{tabular}
\end{center}

\subsection{Правила особого вывода ссылок}

Пусть есть конструкция

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void func(T&& x);
\end{minted}

Пусть есть вызов func(expression), expression имеет тип E. Тогда если expression, является lvalue, T выводится как E\&, если же expression является rvalue, то T выводится как E.

Примеры:

\begin{center}
\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
lvalue: & rvalue:\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{double pi = 3.14;}
& \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{
func(pi);}
&
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{
func(4);}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{
pi - lvalue типа double, T -> double& , сигнатура func: }
&
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{
4 - rvalue типа int, тогда T -> int, сигнатура func: } \\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{
void func<double&>(double& &&);}
&
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{void func<int>(int&&);} \\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
после reference collapsing & \vspace{\baselineskip} \\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\mintinline[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}{
void func<double&>(double&);
} & \vspace{\baselineskip} \\
\end{tabular}

\end{center}


\vspace{\baselineskip}

	Отметим, что переменная типа T\&\&, использованная в функции выше, не всегда является rvalue-ссылкой, и называть её rvalue-ссылкой некорректно. В книге Скота Майерса “Эффективный и современныи С++” эти ссылки названы универсальными. Причины такого наименования станут ясны далее.

	Эти правила применяются для решения проблемы perfect forwarding.

\subsection{Решение проблемы perfect forwarding}

	Рассмотрим код способы передачи аргумента в g:

	\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
	template <typename T>
	void f(T&& x)
	{
	    //Как можно передать x в g?
	    g(x); //передать как lvalue
	    g(std::move(x)); //передать как rvalue
	}

	\end{minted}

	Ни один ни другой способ не подходит. x должно передаваться так же, как получается, то есть поставлена задача сохранения value-category: пришедшее как rvalue значение, должно быть передано как rvalue, а пришедшее как lvalue - как lvalue.

	Рассмотрим вспомогательную функцию, с помощью которой мы будем это делать.

	\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
	template <typename U>
	U&& forward(U& a)
	{
	    return static_cast<U&&>(a);
	}
	\end{minted}

	Тогда код, использующий её, будет выглядеть так

	\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
	template <typename T>
	void f(T&& a)
	{
	    g(forward<T>(a));
	}
	\end{minted}

	Данная функция реализует perfect forwarding. Чтобы убедиться в этом рассмотрим процесс вызова f для rvalue и lvalue и посмотрим на процесс вывода и подстановки аргументов шаблона.

\begin{center}
\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
lvalue: & rvalue:\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
int a; & \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
f(a); & f(5);\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
a - lvalue типа int, поэтому T выводится в int\&, тогда после подстановки, до применения reference collapsing f выглядит так: & 5 - rvalue типа int, следовательно Т выводится в int, а после подстановки f выглядит так:\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int&>(int& && a)
{
    g(forward<int&>(a));
}
\end{minted}
&
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int>(int&& a)
{
    g(forward<int>(a));
}
\end{minted}
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
После применения reference collapsing, она будет выглядеть так:
& \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int&>(int& a)
{
   g(forward<int&>(a));
}
\end{minted}
& \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
В forward в качестве U передают int\& (явно, в треугольных скобочках). Таким образом после подстановки forward выглядит так:
 & В forward в качестве U передают int (явно, в треугольных скобочках), и после подстановки forward выглядит так:
\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int& && forward<int&>(int& & a)
{
    return static_cast<int& &&>(a);
}
\end{minted}
 & \begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int&& forward<int>(int& a)
{
    return static_cast<int&&>(a);
}

\end{minted}
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
После reference collapsing: & \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int& forward<int&>(int& a)
{
     return static_cast<int&>(a);
}

\end{minted}
 & \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
Заметим, что эта функция не делает ничего, а просто кастит int\& к int\&. Поскольку forward возвращает int\&, то результат его вызова - lvalue.Значит f передаёт свой аргумент в g как lvalue. Заметим, что изначально в f a пришла как lvalue. Значит, для lvalue передача работает корректно. & Заметим, что в данном случае функция forward работает как move(приводит lvalue-ссылку к rvalue-ссылке). Результат вызова функции forward является rvalue, то есть f передаёт a как rvalue. Заметим, что получали мы её тоже как rvalue, значит, для rvalue передача работает корректно.\\
\end{tabular}

\end{center}

	Итого, мы сохранили value-category. forward работает либо как ничего (если ей передано lvalue), либо как move(если ей передано rvalue).

\subsection{Одна частая ошибка при использовани forward}
	Иногда при вызове forward забывают указать template-параметр в треугольных скобках. Выглядит это так:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void f(T&& a)
{
    g(forward(a));
}


\end{minted}

	Покажем, почему это ошибка и как от неё избавиться. Расмотрим вызовы для lvalue и rvalue.

\begin{center}
\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
lvalue: & rvalue:\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
int a; & \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
f(a); & f(5);\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
a - lvalue типа int, поэтому T выводится в int\&, тогда после подстановки, до применения reference collapsing f выглядит так: & 5 - rvalue типа int, следовательно Т выводится в int, а после подстановки f выглядит так:\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f(int& && a)
{
    g(forward(a));
}
\end{minted}
&
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f<int>(int&& a)
{
    g(forward(a));
}

\end{minted}
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
После применения reference collapsing, она будет выглядеть так:
& \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void f(int& a)
{
    g(forward(a));
}
\end{minted}
& \vspace{\baselineskip}\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
Типы для forward выводятся следующим образом:
a имеет тип int\&, а forward принимает U\&, таким образом, U выводится как int. Тогда forward выглядит следующим образом::
 & U выводится как int\&\&, тогда вместо U\& подставляется int\&\& \& (сжимается в int\&\&), а вместо U\&\& подставляется int\&\& \&\& (сжимается в int\&\&) Тогда forward выглядит следующим образом:
\\
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int&& forward(int& a)
{
    return static_cast<int&&>(a);
}

\end{minted}
 & \begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int&& forward(int& a)
{
    return static_cast<int&&>(a);
}


\end{minted}
\end{tabular}

\begin{tabular}{p{0.4\linewidth}p{0.4\linewidth}}
То есть forward для lvalue работает как move, а должен рабоать как ничего. & Таким образом, для rvalue forward тоже сработает как move.\\
\end{tabular}

\end{center}

	Мы выяснили, что, если в forward не указать параметр в треугольных скобках, то он всегда будет работать как move.

	Как можно решить эту проблему? Нужно запретить выводить тип для forward, а позволить только явно указывать его. Давайте запретим вывод типа в forward. Рассмотрим вспомогательный класс.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct no_deduce
{
    typedef T type;
}
\end{minted}

	Запишем новую версию forward:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename U>
U&& forward(typename no_deduce<U>::type& a)
{
     return static_cast<U&&>(a);
}
\end{minted}

	Заметим, что typename no\_deduce<U>::type\& эквивалентно U\&.

	Эта конструкция запрещает вывод типов, так как при передаче значения в функцию нам нужно вывести не U\&, а typename no\_deduce<U>::type\&, а это невыводимый контекст. Компилятор может определить, каким типом должен быть no\_deduce<U>::type (пусть он должен иметь тип E), но он не способен вывести тип U, чтобы no\_deduce<U>::type имел тип E (В данном конкретном случае это сделать можно (U должен совпадать с E), но в общем случае такая задача неразрешима, поэтому компилятор C++ не выводит типы в таких случаях).

	Проблема решена.

	Отметим напоследок, что forward есть в стандартной библиотеке.

\subsection{Использование perfect forwarding}

	Perfect forwarding используется, например, при использовании функций высшего порядка - то есть функций, принимающих другие функции в качестве аргументов или возвращающих их в качестве возвращаемого значения.

	Без perfect forwarding, применение функций высшего порядка довольно обременительно, так как нет удобного способа передать аргументы в функцию внутри функции-обертки.
	Возвращаясь к примеру, изложенному в начале главы, функцию-обёртку над конструктором типа T make\_unique с использованием perfect forwarding  можно реализовать следующим образом:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T, typename… Args>
//тип T - тип, обёртываемый в shared_ptr, Args - типы аргументов конструктора.
shared_ptr<T> make_unique(Args&&... args)
{
    return unique_ptr<T>(new T(std::forward<Args>(args)...))
}
\end{minted}

	Про используемые в коде variadic template можно подробнее узнать в следующей главе.
