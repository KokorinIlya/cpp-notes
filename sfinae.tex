\section{SFINAE}

\subsection{Возвращаясь к перегрузке функций}

	Прежде чем рассматривать SFINAE, полезно вспомнить правила разрешения перегрузок в C++. Неформально говоря, встречая в коде вызов функции f с каким-то списком параметров, компилятор собирает все функции с этим именем, до которых может дотянуться (основываясь на правилах поиска в пространствах имён) и составляет из них список кандидатов. На этом этапе компилятор не интересуют ни список параметров, ни возвращаемое значение, ни тело функции. Список кандидатов составляется только из функций, имеющих нужное имя, до которых можно дотянуться.
	
	Например, если совершён вызов f(1), компилятор может добавить в список функции со следующей сигнатурой:
	
	\begin{verbatim}
	double f(double, double = 0)
	int f(int, int = 0)
	bool f(std::vector<bool>)
	float f(float)
	long f(long, long)
	\end{verbatim}
	
	Далее начинается процесс отсева функций из списка кандидатов и его сужение. Отметим, что начиная с данного этапа размер списка будет только сужаться и увеличиваться более не будет. На этом шаге из списка удаляются те функции, которые никак не могут быть вызваны с данным списком параметров, то есть те, размер списка параметров которых (с учётом параметров по умолчанию) не совпадает с размером списка параметров вызываемой функции. То есть удалена будет функция long f(long, long).
	
	На следующем этапе исключаются функции, типы параметров которых отличаются от типов переданных аргументов, и при этом отсутствует способ преобразовать тип параметра в тип аргумента (то есть отсутствует конструктор преобразования или оператор преобразования). На этом этапе будет исключена 
bool f(std::vector <bool>)
	
	После этого из списка оставшихся кандидатов компилятор выберет функцию, лучше всего соответствующую вызванной. В нашем случае это будет функция 
int f(int, int = 0), так как она не требует преобразования аргументов. Эта функция и будет вызвана. 

	Отметим, что если на последнем этапе выбор осуществить не удаётся (то есть одинаковое соответствие дают несколько функций-кандидатов или в списке кандидатов не осталось функций), компилятор выдаст сообщение об ошибке. Например, в случае наличия функций
	
	\begin{verbatim}
	void f(int, double)
	void f(double, int)
	\end{verbatim}
	
	и вызова f(1, 1), компилятор объявит о неоднозначности.

\subsection{Перегрузка и шаблонные функции}
	Теперь посмотрим, что произойдёт при добавлении к списку функций с подходящим именем шаблонной функции.

	Пусть в нужной нам области видимости существует шаблонная функция с сигнатурой
	
	\begin{verbatim}
	template <typename T>
	T f(T)
	\end{verbatim}
	
	Что изменится в вышеприведённом алгоритме? Изменится первая стадия. Если при поиске функций с нужным нам именем компилятор видит шаблонную функцию, он не сразу добавляет её в список кандидатов, а пытается произвести вывод её аргументов\footnote{%
	Дедукция аргументов шаблона - сложная и многозначная тема, желающим изучить её подробнее я я бы посоветовал прочитать соответствующую главу из книги Скота Майерса "Эффективный и современный C++".}.
	
	Если аргументы шаблона удалось вывести, функция с выведенными аргументами добавляется в список кандидатов. Заметим, что это происходит на первом шаге, когда для нешаблонных функций сравнивается только имя, без анализа аргументов.
	
	Таким образом, на первом этапе в список кандидатов добавится функция int f<int> (int); на дальнейших этапах она будет по таким же правилам участвовать в процессе определения перегруженной функции. 
	
	Согласно правилам разрешения перегрузок в C++, нешаблонная функция при прочих равных условиях предпочитается шаблонной. Следовательно, в конце будет выбрана не f<int>(int), а f(int, int = 0), так как эта функция не шаблонная.
	
	Выше было сказано, что если удаётся произвести дедукцию аргументов шаблона функции, то она, с выведенными аргументами, добавляется в список кандидатов. Что же происходит, если типы аргументов шаблона функции по какой-то причине не удаётся вывести или подставить? Ответ прост: ничего не происходит, функция просто не добавляется в список кандидатов при перегрузке и в дальнейшем рассмотрении не участвует. Это и есть правило SFINAE - Substitute Failure Is Not An Error, то есть неудача при подстановке - это не ошибка.
	
	\vspace{\baselineskip}	
	
	Отметим, что хотя в контексте этого правила ошибки подстановки и вывода ведут себя одинаково (какая бы из них не произошла, шаблон функции просто не будет добавлен в список кандидатов), в общем случае это разные ошибки.
	
	Например, в следующем коде:
	
	\begin{verbatim}
	template <typename T>
	void f(T x, T y)
	{
	    ///Тело функции
	}
	
	f(5, vector<int>());
	\end{verbatim}
	
	Происходит ошибка вывода, так как неизвестно, в какой тип вывести T.
	
	А в коде:
	
	\begin{verbatim}
	template <typename T>
	void f(T::size_type x = 0)
	{
	    ///Тело функции
	}
	
	f<int>();
	\end{verbatim}
	
	Происходит ошибка подстановки так как тип T известен, но int::size\_type не существует, следовательно, невозможно подставить типы параметров в сигнатуру шаблона.
	
	Отметив это соображение, вернёмся к рассмотрению самого правила SFINAE.
	
	\vspace{\baselineskip}	
	
	При дедукции и подстановке аргументов рассматривается исключительно сигнатура функции и ничего больше, её тело не анализируется. Иными словами, если при выводе аргументов шаблона ошибки не произошло, функция была добавлена в список кандидатов и оказалась самой подходящей, но в её теле содержалась ошибка, компилятор поймёт это уже на этапе вызова и завершит компиляцию с ошибкой. Правило SFINAE работает только при выводе аргументов шаблона и учитывает только сигнатуру функции.

	Например, если есть набор функций

	\begin{verbatim}
	template <typename T>
	void f(T x)
	{
	    x.method_that_T_does_not_have();
	}

	void f(double x)
	{
	    cout << x;
	}
	\end{verbatim}
	
	и вызвано f(1);
	список кандидатов будет состоять из:
	
	\begin{verbatim}
	void f<int> (int x);
	void f(double x);
	\end{verbatim}

	Будет выбрана шаблонная функция, но при попытке скомпилировать вызов произойдёт ошибка, так как int не имеет метода method\_that\_T\_does\_not\_have;

	Прежде чем перейти к подробному рассмотрению этого правила, хотелось бы отметить ещё раз, что это SFINAE работает только при составлении списка кандидатов при перегрузке функций и при анализе учитывается только сигнатура функции, без рассмотрения её тела.

\subsection{Использование SFINAE для ограничения при компиляции}

	Разобравшись с тем, как работает SFINAE, научимся применять его на практике. Пусть нам нужно решить следующую задачу: написать функцию print\_all, которая, если ей передан контейнер с возможностью последовательного доступа, печатает все его элементы в нужном порядке.
	
	Давайте определимся, как мы будем печатать элементы контейнера. Если x - контейнер типа T, то его элементы печатаются с помощью кода

	\begin{verbatim}
	cout << "container : { ";
	for (T::const_iterator it = x.begin(); it != x.end(); it++)
	{
	    cout << (*it) << " ";
	} 
	cout << "}";
	\end{verbatim}

	У контейнеров последовательного доступа есть итераторы, позволяющие проходиться по ним. Тогда с помощью SFINAE нам нужно гарантировать наличие у типа T итератора (вернее, константного итератора, так как нам нужно просто получать элементы, но не изменять их).
	
	Напишем функцию для типа T - последовательного контейнера

	\begin{verbatim}
	template <typename T, typename ITER = typename T::const_iterator>
	void print_all(T const& x)
	{

	    cout << "container : { ";
	    for (ITER it = x.begin(); it != x.end(); it++)
	    {
	        cout << (*it) << " ";
	    } 
	    cout << "}";
	}
	\end{verbatim}
	
	Рассмотрим процесс вызова print\_all(std::vector<int>);
	
	T выводится как std::vector<int>;
	
	Вместо ITER подставляется std::vector<int>::const\_iterator;
	
	Подстановка успешна, функция будет добавлена в список кандидатов и будет вызвана, так как является единственной функцкцией в списке кандидатов

	Рассмотрим результат вызова print\_all(int);
	
	T выводится как int;
	
	Вместо ITER должно быть подставлено int::const\_iterator, но происходит ошибка инстанцирования, нет типа int::const\_iterator. Функция будет исключена из рассмотрения на этапе перегрузки. Компилятор сообщит нам, что функция print\_all не может быть вызвана с типом int, так как нет подходящей перегрузки.

	В дальнейшем мы напишем перегрузку для типов, у которых нет итератора, но для которых имеет смысл операция печати, а пока давайте рассмотрим возможность применения SFINAE не в шапке шаблона, а в других местах.

	Можно применить его в списке параметров функции, как в следующем примере:
	
	\begin{verbatim}
	template <typename T>
	void print_all(T const& x, typename T::const_iterator* = nullptr)
	{

	    cout << "container : { ";
	    for (ITER it = x.begin(); it != x.end(); it++)
	    {
	        cout << (*it) << " ";
	    } 
	    cout << "}";
	}
	\end{verbatim}	
	
	Мы вводим фиктивный безымянный параметр типа указателя на T::const\_iterator, инициализируемый по умолчанию nullptr. Инициализация по умолчанию позвоняет нам вызывать эту функцию с одним параметром, вместо второго (при успехе подстановки T::const\_iterator) всегда будет подставляться nullptr.
		
	Рассмотрим процесс вызова print\_all(std::vector<int>);
		
	T выводится как std::vector<int>
		
	Вместо typename T::const\_iterator подставляется std::vector<int>::const\_iterator

	Сигнатура функции выглядит следующим образом:

	\begin{verbatim}
	void print_all(std::vector<int> const& x, 
	    typename std::vector<int>::const_iterator* = nullptr)
	\end{verbatim}	
	
	Подстановка успешна, функция будет добавлена в список кандидатов и будет вызвана, так как является единственной функцкцией в списке кандидатов
	
	
	Рассмотрим процесс вызова print\_all(int);
		
	T выводится как int
		
	Вместо typename T::const\_iterator должно быть подставлено int::const\_iterator, но происходит ошибка подстановки, так как такого типа не существует, функция не будет включена в список кандидатов
	
	Рассмотрим использование SFINAE в типе возвращаемого значения
	
	\begin{verbatim}
	template <typename T>
	? print_all(T const& x)
	{

	    cout << "container : { ";
	    for (ITER it = x.begin(); it != x.end(); it++)
	    {
	        cout << (*it) << " ";
	    } 
	    cout << "}";
	}
	\end{verbatim}
	
	Нужно определить, какой тип подставить вместо знака вопроса. Так как функция print\_all должна всегда возвращать void, нам нужно поместить сюда какой-то тип, являющийся void в случае, если T - контейнер и мешающий подстановке в противном случае. Научимся писать такие типы.
	
	\subsection{type traits}
	
	Рассмотрим класс
	
	\begin{verbatim}
	template <bool condition, typename T = void>
	struct enable_if {};
 
	template <typename T>
	struct enable_if<true, T>
	{
	    typedef type T;
	};
	\end{verbatim}
	
	Это шаблон класса, параметрами котрого являются условие и некоторый тип, со специализацией для истинного значения условия. Если условие истинно, enable\_if определяет type, являющийся синонимом для типа, переданного ему. Если условие ложно, то он не содержит ничего. 
	
	Подумаем, как можно написать функцию print\_all, воспользовавшись этим классом. Для начала запретим вызывать нашу функцию для интегральных типов. Является ли тип интегральным можно узнать с помощью std::is\_integral<T>::value. Если T интегральный, то value == true, иначе false.

	\begin{verbatim}
	template <typename T>
	typename enable_if<!is_integral<T>::value, void>::type print_all(T const& x)
	{

	    cout << "container : { ";
	    for (ITER it = x.begin(); it != x.end(); it++)
	    {
	        cout << (*it) << " ";
	    } 
	    cout << "}";
	}
	\end{verbatim}

	Рассмотрим процесс вызова print\_all(std::vector<int>)
	
	T выводится как std::vector<int>
	
	std::vector<int> - не интегральный тип, поэтому 
	
	is\_integral<std::vector<int> >::value == false, 
	
	!is\_integral<std::vector<int> >::value == true, 
	
	тогда enable\_if<!	is\_integral<std::vector<int> >::value, void> 
	
	содержит поле type, свляющееся синонимом для void, тогда сигнатура функции имеет вид:

	\begin{verbatim}
	void print_all(std::vector<int> const& x);
	\end{verbatim}

	Рассмотрим процесс вызова print\_all(int)
	
	T выводится как int
	
	int - Интегральный тип, поэтому is\_integral<int>::value == true
	
	!is\_integral<int>::value == false, тогда 
	
	enable\_if<!is\_integral<int>::value, void> 
	
	не содержит поля type, произойдёт ошибка подстановки, функция не будет добавлена в список кандидатов.
	
	\vspace{\baselineskip}
	
	То есть enable\_if позволяет как бы отключать функции на этапе компиляции для определённых условий.
	
	Отметим, что тип void в enable\_if можно не писать, так как void является значением по умолчанию параметра шаблона enable\_if.

	Заметим, что предыдущий код был не идеален, так как то, что тип не является интегральным, вовсе не означает, что он является последовательным контейнером, для этого нужно более сильное условие - существование итератора.

	Научимся проверять, если ли у типа T const\_iterator. Для этого давайте потренируемся в написании type\_traits и напишем структуру is\_const\_iterator<T, I>, которая содержит value == true, если I является константным итератором из T, и == false иначе.

	\begin{verbatim}
	template <typename T1, typename T2>
	struct is_const_iterator
	{
        static const bool value = false;
	};

	template <typename T>
	struct is_const_iterator<T, typename T::const_iterator>
	{
 	    static const bool value = true;
	};
	\end{verbatim}
	
	Это шаблон класса от двух параметров со специализацией для случая, когда второй параметр является константным итератором первого. 
	
	Так как C++ из всех подходящих шаблонов классов выбирает наиболее узкий, то если оба шаблона допустимы, будет выбран второй. Если же второй шаблон недопустим (то есть I не является константным итератором T), то будет выбан первый шаблон, как единственный вариант.
	
	Напишем новую версию print\_all, использующую этот type\_traits.
	
	\begin{verbatim}
	template <typename T>
	typename enable_if<is_const_iterator<T, typename T::const_iterator>
	    ::value, void>::type print_all(T const& x)
	{
	    cout << "container : { ";
 	    for (typename T::const_iterator it = x.begin(); it != x.end(); it++)
	    {
            cout << (*it) << " ";
	    }
	    cout << "}";
	}
	\end{verbatim}

	Этот код просто проверяет наличие у типа T константного итератора.
	
	Рассмотрим процесс вызова print\_all(std::vector<int>)
	
	T выводится как std::vector<int>
	
	is\_const\_iterator<std::vector<int>, std::vector<int>::const\_iterator>::value == true
	
	тогда enable\_if<is\_const\_iterator<T, typename T::const\_iterator>::value, void> содержит type, являющийся синонимом для void.
	
	Сигнатура функции имеет вид
	
	\begin{verbatim}
	void print_all(std::vector<int> const&)
	\end{verbatim}

	Подстановка успешна, функция будет добавлена в список кандидатов и будет вызвана, так как является единственной функцкцией в списке кандидатов
	
	Рассмотрим процесс вызова print\_all(int);
	
	T выводится как int
	
	Попытка посчитать 
	
	is\_const\_iterator<int, int::const\_iterator>::value вызовет ошибку подстановки, так как у int нет const\_iterator. 
	
	Функция не будет добавлена в список кандидатов.
	
	\vspace{\baselineskip}
	
	Можно написать и проще. Поймём, что нам не нужно уметь проверять два типа на то, является ли второй константным итератором первого, нам нужно просто уметь проверять, если ли у типа T const\_iterator. Это можно сделать намного проще.

	Заведём структуру, которая всегда, независимо от переданного ей типа, хранит value == true.
	
	\begin{verbatim}
	template <typename T>
	struct always_say_yes
	{
        static const bool value = true;
	};
	\end{verbatim}
	
	Перепишем функцию с использванием этой структуры данных
	
	\begin{verbatim}
	template <typename T>
	typename enable_if<always_say_yes<typename T::const_iterator>::value>::type 
	    print_all(T const& x)

	{
	    cout << "container : { ";
 	    for (typename T::const_iterator it = x.begin(); it != x.end(); it++)
	    {
            cout << (*it) << " ";
	    }
	    cout << "}";
	}
	\end{verbatim}
	
	Рассмотрим процесс вызова print\_all(std::vector<int>)
	
	T выводится как std::vector<int>
	always\_say\_yes<std::vector<int>::const\_iterator>::value == true
	
	тогда enable\_if<always\_say\_yes<std::vector<int>::const\_iterator>::value> содержит type, являющийся синонимом для void (тип void - тип enable\_if по умолчанию).
	
	Сигнатура функции имеет вид
	
	\begin{verbatim}
	void print_all(std::vector<int> const&)
	\end{verbatim}
	
	Подстановка успешна, функция будет добавлена в список кандидатов и будет вызвана, так как является единственной функцкцией в списке кандидатов.
	
	Рассмотрим процесс вызова print\_all(int)
	
	T выводится как int
	
	При попытке инстанцировать always\_say\_yes<int::const\_iterator> - происходит ошибка подстановки, так как у int нет const\_iterator. Функция не будет добавлена в список кандидатов.

	\vspace{\baselineskip}
	
	Напишем ещё один type\_traits, чтобы закрепить умение их писать. напишем структуру is\_same <T1, T2>, содержащая член value == true, если типы совпадают, и false в противном случае

	\begin{verbatim}
	template <typename T1, typename T2>
	struct is_same
	{
	    static const bool value = false;
	};
 
	template <typename T>
	struct is_same<T, T>
	{
	    static const bool value = true;
	};
	\end{verbatim}
	
	Отметим, что очень много type\_traits’ов (в том числе написанных нами) есть в стандартной библиотеке, в файле type\_traits.h

	Многие type\_traits (например, is\_trivially\_copiable, is\_trivially\_destructible, is\_integral и т.д) не могут быть написаны стандартными средствами языка и реализованы с помощью информации, доступной только компилятору. Мы не можем написать их, поэтому нам остаётся только использовать уже написанные до нас.
	
	\subsection{Выбор необходимой перегрузки на этапе компиляции}
	
	Рассмотрим задачу вывода на экран элементов контейнера. Заметим, что иногда нам нужно выводить на экран элементы контейнера, не имеющего итераторов. Например, можно рассмотреть задачу вывода на экран элементов обыкновенного массива.
	
	Попробуем использовать наш ранее использовавшийся код для печати элементов массива. Например, используем

	\begin{verbatim}
	template <typename T, typename ITER = typename T::const_iterator>
	void print_all(T const& x)
	{

	    cout << "container : { ";
	    for (ITER it = x.begin(); it != x.end(); it++)
	    {
	        cout << (*it) << " ";
	    } 
	    cout << "}";
	}
	\end{verbatim}

	Рассмотрим процесс вызова:
	
	\begin{verbatim}
	int a[50];
	print_all(a);
	\end{verbatim}
	
	T выводится в int* (при выводе типов массив типа T неявно конвертируется в указатель на тип T)
	
	При попытке инстанцировать int*::const\_iterator происходит ошибка подстановки, так как int* не имеет члена const\_iterator 
	
	Заметим, что сейчас мы не можем использовать эту функцию для печати массивов. Напишем для это цели перегрузку.
	
	\begin{verbatim}
	template <typename T>
	void print_all(T* const ptr, size_t N)
	{

	    cout << "array : { ";
	    for (size_t i = 0; i < N; ++i)
	    {
	        cout << *(ptr + i) << " ";
	    } 
	    cout << "}";
	}
	\end{verbatim}	

	В таком случае при вызове print\_all(a, 50) не удастся вывести тип в первом случае, и эта функция не будет добавлена в список кандидатов.
	
	Во втором же случае вывод типов будет корректен(T выводится int), функция добавится в список кандидатов и будет успешно вызвана.
	
	Аналогично можно выбирать один из вариантов перегруженной функции, основываясь на информации о типах, известной на момент компиляции.

	\vspace{\baselineskip}
	
	Отметим, что использование SFINAE с помощью наличия дополнительного типа в шапке шаблона имеет один очень значительный недостаток. Дело в том, что параметр шаблона по умолчанию не является частью сигнатуры функции.

	Например, пусть есть функции

	\begin{verbatim}
	template <typename T, typename DEFAULT = enable_if<is_integral<T>::value>
	void f(T x);
	\end{verbatim}
	
	и
	
	\begin{verbatim}
	template <typename T, typename DEFAULT = enable_if<!is_integral<T>::value>
	void f(T x);
	\end{verbatim}
	
	Мы понимаем, что это две разные функции, применяемые в разных случаях (тип является либо интегральным, либо не интегральным, он не может быть одновременно и таким и таким). Но параметр шаблона DEFAULT - параметр шаблона по умолчанию, следовательно, он не является частю сигнатуры функции и две эти функции считаются одинаковыми. Поэтому предпочтительным вариантом использования SFINAE является его использование через дополнительный параметр или через возвращаемое значение.
	
	\vspace{\baselineskip}	
	
	Напишем, например, деструктор вектора. Как он должен быть написан? 
	
	Пусть вектор выделил кусок динамической памяти типа T* storage, размер которого size\_t capacity, а заполнено size\_t size элементов. Нужно пройтись циклом по заполненным элементам и вызвать на них деструкторы, чтобы гарантировать их корректное уничтожение (например, в векторе могут лежать классы, реализующие идиому RAII, уничтожение которых с помощью деструктора освобождает некий ресурс, так что уничтожение их без использования деструктора будет некорректно, так как захваченный ими ресурс останется неосвобождён).
	
	 С другой стороны, возможна оптимизация: если деструктор типа T тривиален, то нет смысла пробегаться по элементам вектора и вызывать их деструкторы, можно сразу удалить storage.
	 
	 Нельзя использовать SFINAE в самом деструкторе вектора, так как может существовать всего одна перегрузка деструктора. Следовательно, нужно в деструкторе вызывать перегруженную функцию. Необходимая перегрузка будет выбираться на основании информации о типе T, которым параметризован vector.
	 
	 Пусть деструктор вектора выглядит следующим образом:

	\begin{verbatim}
	~vector()
	{
	    destroy_storage(storage);
	}
	\end{verbatim}
	
	Напишем две перегрузки для destroy\_storage: для тривиально и нетривиально уничтожаемых типов, воспользуемся is\_trivially\_destructible из стандартной библиотеки, работающим подобно разобранным выше type-traits.
	
	\begin{verbatim}
	template <typename U>
	typename enable_if<!is_trivially_destructible<U>::value>
	    ::type destroy_storage(U* _storage)
	{
	    for (size_t i = 0; i < size; i++)
	    {
	         data[i].~U();
	    }
	    operator delete(storage);
	}
	\end{verbatim}
	
	Теперь напишем перегрузку для типов с тривиальным деструктором

	\begin{verbatim}
	template <typename U>
	typename enable_if<is_trivially_destructible<U>::value>
	    ::type destroy_storage(U* _storage)
	{
	    //типы тривиально удаляемые, нет смысла вызывать деструктор
	    operator delete(storage);
	}
	\end{verbatim}
	
	Рассмотрим вызов деструктора вектора, параметризованного некоторым тривиально уничтожаемым типом, например, vector<int>
	
	Пытаемся произвести дедукцию аргументов первой перегрузки.
	
	U выводится как int
	
	int тривиально уничтожаем, так что is\_trivially\_destructible<U>::value == true
	
	!is\_trivially\_destructible<U>::value == false
	
	При попытке вывести несуществующий тип enable\_if<false>::type происходит ошибка подстановки, функция не будет добавлена в список кандидатов.
	
	\vspace{\baselineskip}		
	
	Пытаемся провести дедукцию аргументов второй перегрузки.
	
	U выводится как int.
	
	int тривиально уничтожаем, так что is\_trivially\_destructible<U>::value == true
	enable\_if<true>::type == void
	
	Все типы удалось вывести, функция будет добавлена в список кандидатов (и будет в нём единственной). Следовательно, именно она и будет вызвана в деструкторе.
	
	\vspace{\baselineskip}		
	
	Аналогично (но с противоположным результатом) происходит вызов desroy\_storage для какого-нибудь нетривиально уничтожаемого типа (например, shared\_ptr<int>).

	\subsection{Дополнительные возможности SFINAE}
	
	Иногда полезно бывает вызвать одну из перегрузок функции в зависимости от того, есть ли в классе T имя T::name. Напишем метафункцию, которая будет это определять.

	Основная идея такова: пусть у нас есть две фукнции check\_name, одна из которых может принять значение типа typename T::name*, а вторая принимает что угодно. Они должны возвращать значения разных типов, размеры которых не совпадают (например, int\_16t и int\_32t)
	
	При отсутствии typename T::name первая перегрузка будет отсечена по SFINAE, и, следовательно, недоступна, значит, будет выбрана вторая. При наличии typename T::name будут доступны обе перегрузки, но выбрана должна быть первая (она должна обладать большим приоритетом). 

	Тогда вызовем check\_name(nullptr). Так как nullptr может быть приведён к typename T::name* (при наличии такого имени), должна быть вызвана первая перегрузка. Сравним размер значения, возвращаемого функцией check\_name(nullptr). Если он равен размеру значения, возвращаемого первой перегрузкой, то может быть вызвана функция check\_name(typename T::name*), следовательно, существует typename T::name. Если же он равен размеру значения, возвращаемого второй перегрузкой, то такого имени не существует и функция не может быть вызвана.
	
	Как написать функцию, принимающую что угодно? Для этого можно воспользоваться конструкцией (...). Тогда перегрузки выглядят следующим образом:

	\begin{verbatim}
	template <typename T>
	int_16t check_name(typename T::name*);

	int_32t check_name(...);
	\end{verbatim}
	
	Вторая перегрузка пока не отвечает нашим требованиям: она может принимать всё, что угодно, но обладает большим приоритетом, чем первая, и будет вызываться всегда (так как нешаблонная функция предпочитается шаблонной при прочих равных условиях).

	Сделаем вторую функцию также шаблонной. Теперь функции выглядят так:
	
	\begin{verbatim}
	template <typename T>
	int16_t check_name(typename T::name*);
	
	template <typename T>
	int32_t check_name(...);
	\end{verbatim}
	
	Теперь обе перегрузки отвечают нашим требованиям, то есть вторая принимает что угодно и имеет меньший приоритет, чем первая, и при наличии обеих перегрузок будет вызвана именно первая. Первая перегрузка отсекается по SFINAE при отсутствии typename T::name
	
	Тогда класс, проверяющий наличие имени, выглядит следующим образом:

	\begin{verbatim}
	template <typename T>
	struct has_name
	{
	    //Используем явное указание типа шаблона, так как в противном случае
	    //компилятор не сможет вывести самостоятельно для второй перегрузки,
	    //так как неизвестны типы принимаемых ей параметров
	    static const bool value = sizeof(check_name<T>(nullptr) == sizeof(int16_t));
	};
	\end{verbatim}

	Заметим, что нет необхоимости писать тела функций, так как sizeof не вычисляет значение указанного внутри выражения, а только возвращает размер его типа.
	
	Напишем две перегрузки функций, работаюих по-разному, в зависимости от наличия в T имени name
	
	\begin{verbatim}
	template <typename T>
	typename enable_if<has_name<T>::value>::type use_name(T const& x)
	{
	    cout << "Has name" << endl;
	}

	template <typename T>
	typename enable_if<!has_name<T>::value>::type use_name(T const& x)
	{
	    cout << "A type has no name" << endl;
	}
	\end{verbatim}
	
	\vspace{\baselineskip}	
	Научимся проверять существование в типе необходимой функции.
	
	Пусть мы хотим проверить, есть ли в типе T функция f, которая может принять int. Воспользуемся методом из предыдущей проверки, немного модернизировав его.

	Изменим первую перегрузку. Заведём пустой тип

	\begin{verbatim}
	template <int N>
	struct integral_constant {};
	\end{verbatim}
	
	Будем параметризовать его размером результата вызова f(int). Если такой вызов может быть осуществлён, то параметризация integral\_constant будет успешна, ошибки инстанцирования шаблона не произойдёт и будет вызвана первая перегрузка.
	
	 Если же такой функции нет, то размер результата вызова f(int) неизвестен, integral\_constant не сможет быть параметризована этим размером, и будет вызывна вторая перегрузка.
	 
	  Тогда первая перегрузка выглядит следующим образом:
	  
	\begin{verbatim}
	template <typename T>
	int16_t has_f_help(integral_constant<sizeof(/*размер вызова T::f(int)*/)>*);
	\end{verbatim}
	
	Размер вызова T::f(int) может быть получен как sizeof(T().f(5)). Тогда код будет выглядеть так:
	
	\begin{verbatim}
	template <typename T>
	int16_t has_f_help(integral_constant<sizeof(T().f(5))>*);
	\end{verbatim}
	
	У этого метода есть два недостатка. Во-первых, тип T может не иметь конструктора по умолчанию, тогда конструкция T() будет некорректна. Во-вторых, если бы вместо типа int был бы какой-то другой тип, то вместо 5 пришлось бы придумать какое-то типичное значение другого типа, а это не всегда возможно. Заметим, что обе эти проблемы можно решить с помощью функции std::declval<U>, возвращающей какое-то значение типа, переданного ей в качестве шаблонного параметра. Перепишем код с использованием этой функции.

	\begin{verbatim}
	template <typename T>
	int16_t has_f_help(integral_constant<sizeof(declval<T>().f(declval<int>()))>*);
	\end{verbatim}
	
	Вторая перегрузка выглядит как же, как и раньше. Тогда код проверки и функций, использующих её, выглядит следующим образом:

	\begin{verbatim}
	template <int N>
	struct integral_constant{};

	template <typename T>
	int16_t has_f_help(integral_constant<sizeof(declval<T>().f(declval<int>()))>*);

	template <typename T>
	int32_t has_f_help(...);

	template <typename T>
	struct has_f
	{
	    static const bool value = sizeof(has_f_help<T>(nullptr)) == sizeof(int16_t);
	};


	template <typename T>
	typename enable_if<has_f<T>::value>::type check_f(T const& x)
	{
	    cout << "Has f" << endl;
	}

	template <typename T>
	typename enable_if<!has_f<T>::value>::type check_f(T const& x)
	{
	    cout << "No f" << endl;
	}
	\end{verbatim}

	\vspace{\baselineskip}

	Заметим, что можно проверять существование в типе T функции с данной сигнатурой (например, гарантировать существование функции int f(int), а не void f(int)). Для этого воспользуемся предыдущим методом и синтаксисом фуказателей на функции-члены.
	
	Модернизируем наш тип integral\_const, чтобы он содержал type, являющийся синонимом для void.

	\begin{verbatim}
	template <int N>
	struct integral_constant
	{
	    typedef void type;
	};
	\end{verbatim}
	
	Теперь будем пытаться в первой перегрузке параметризовать integral\_const размером указателя на int T::f(int). Для проверки сигнатуры будем с помощью static\_cast конвертировать указатель на T::f к типу int (T::*)(int) (нужная нам сигнатура). Параметром первой перегрузки станет 
	
	\begin{verbatim}
	typename integral_constant<sizeof(static_cast<int (T::*(int)>(&T::f))>::type*. 
	\end{verbatim}
	
	Если такой функции в T не существует, конвертирование будет неудачным, произойдёт ошибка подстановки и первая перегрузка не будет добавлена в список кандидатов. В случае же существования функции с такой сигнатурой, тип параметра первой перегрузки удастся вывести (это будет void*), и даная перегрузка сможет быть вызвана с аргументом nullptr.
	
	Итоговый код выглядит следующим образом:
	
	\begin{verbatim}
	template <int N>
	struct integral_constant
	{
	    typedef void type;
	};

	template <typename T>
	int has_f_help(typename 
	    intergal_constant<sizeof(static_cast<int (T::*(int)>(&T::f))>::type*);

	template <typename T>
	long long has_f_help(...);

	template <typename T>
	struct has_f
	{
	    static const bool value = sizeof(has_f_help<T>(nullptr)) == sizeof(int);
	};

	template <typename T>
	typename enable_if<has_f<T>::value>::type check_f(T const& x)
	{
	    cout << "Has f" << endl;
	}

	template <typename T>
	typename enable_if<!has_f<T>::value>::type check_f(T const& x)
	{
	    cout << "No f" << endl;
	}
	\end{verbatim}
